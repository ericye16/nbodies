<html>
	<head>
		<title>N Bodies</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
		<script src="js/three.min.js"></script>
		<script src="js/OrbitControls.js"></script>
		<script src="js/Stats.js"></script>
		<script>
			var stats = new Stats();
			stats.setMode( 0 ); // 0: fps, 1: ms, 2: mb

			// align top-left
			stats.domElement.style.position = 'absolute';
			stats.domElement.style.left = '0px';
			stats.domElement.style.top = '0px';

			document.body.appendChild( stats.domElement );

			var scene = new THREE.Scene();
			var camera = new THREE.PerspectiveCamera( 30, window.innerWidth/window.innerHeight, 0.1, 1000 );
			var clock = new THREE.Clock;

			var renderer = new THREE.WebGLRenderer();
			renderer.setSize( window.innerWidth, window.innerHeight );
			document.body.appendChild( renderer.domElement );
			camera.position.z = 400;
			controls = new THREE.OrbitControls(camera, document, renderer.domElement); 

			var N = 500;
			var MAX_DIM = 100;
			var MAX_V = 10;
			var SPHERE_RADIUS = 1;
			var SPHERE_WIDTH_SEGS = 3;
			var SPHERE_HEIGHT_SEGS = 2;
			var GRAV_CONSTANT_ACCEL = 10;

			// Returns a random number between min (inclusive) and max (exclusive)
			function getRandomArbitrary(min, max) {
			  return Math.random() * (max - min) + min;
			}

			var material = new THREE.MeshBasicMaterial( { color: 0xffffff } );
			var generateParticle = function() {
				var particle = new THREE.SphereGeometry(SPHERE_RADIUS);
				var sphere = new THREE.Mesh(particle, material);
				sphere.position.x = getRandomArbitrary(-MAX_DIM, MAX_DIM);
				sphere.position.y = getRandomArbitrary(-MAX_DIM, MAX_DIM);
				sphere.position.z = getRandomArbitrary(-MAX_DIM, MAX_DIM);
				sphere.userData.v = new THREE.Vector3();
				sphere.userData.v.x = getRandomArbitrary(-MAX_V, MAX_V);
				sphere.userData.v.y = getRandomArbitrary(-MAX_V, MAX_V);
				sphere.userData.v.z = getRandomArbitrary(-MAX_V, MAX_V);
				sphere.userData.m = getRandomArbitrary(0.8, 8.0);
				return sphere;
			}

			function removeFromScene(object) {
				scene.remove(object);
			}

			function max(a, b) {
				if (a > b) return a; else return b;
			}

			function updateParticles(particles) {
				// var dt = clock.getDelta();
				var dt = 1/60.0;
				// console.log(dt);
				for (var i = 0; i < N; i++) {
					if (particles[i]) {
						var sphere = particles[i];
						sphere.position.addScaledVector(sphere.userData.v, dt);
						for (var j = 0; j < N; j++) {
							if (j != i && particles[j]) {
								var sphere2 = particles[j];
								var ds = new THREE.Vector3();
								ds.subVectors(sphere2.position, sphere.position);
								if (ds.length() < (sphere.geometry.boundingSphere.radius + sphere2.geometry.boundingSphere.radius)) { // collision detected
									// inelastic collision
									var mass = sphere.userData.m + sphere2.userData.m;
									var newV = new THREE.Vector3();
									newV.addScaledVector(sphere.userData.v, sphere.userData.m / mass);
									newV.addScaledVector(sphere2.userData.v, sphere2.userData.m / mass);
									sphere.userData.v = newV;
									sphere.userData.m = mass;
									sphere.scale.max(sphere2.scale);
									sphere.scale.addScalar(0.1);
									removeFromScene(sphere2);
									particles[j] = null;
								} else {
									var newV = new THREE.Vector3();
									var dsNorm = new THREE.Vector3();
									dsNorm.copy(ds);
									dsNorm.normalize();
									newV.addScaledVector(dsNorm, GRAV_CONSTANT_ACCEL * sphere2.userData.m / (ds.lengthSq()));
									sphere.userData.v = newV;
									// console.log((dx / ds) * GRAV_CONSTANT_ACCEL / (ds * ds) * dt);
								}
							}
						}
					}
				}
			}

			particles = [];
			for (var i = 0; i < N; i++) {
				var sphere = generateParticle();
				scene.add(sphere);
				particles.push(sphere);
			}

			var render = function () {
				requestAnimationFrame( render );

				stats.begin();
				updateParticles(particles);

				renderer.render(scene, camera);
				stats.end();
			};

			render();
		</script>
	</body>
</html>
